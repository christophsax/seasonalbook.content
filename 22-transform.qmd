# Transform {#sec-transform}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("course_complete", "2022-12-21", section = "Transform")  # drafting, polishing, complete
```

```{=html}
<!--
-   Discuss multiplicative vs additive adjustment

-   How to use the transform spec

- Transform is a nice way to introduce automatic model testing. Easy to see the decision made. 

-   This is our first chance to mention the idea of test first then hard-code in production

-   Case Study idea: Decide between log vs non-log transformation
 -->
```

In seasonal adjustment, one of the first choices is whether a series needs to be transformed before modeling.
Two types of transformation types typically occur within X-13, *transformations* and *prior modifications*. Prior modifications are rarely used and will be covered in the second section. Tranformations, especially lograitmic transformations, are ubiquitous and central to many seasonal adjustment models.

Below is our standard example. As we have seen before, the automated procedures of X-13 opt for a logarithmic transformation of the series.

```{r}
m_log  <- seas(AirPassengers, x11 = "")
summary(m_log)
plot(m_log)
```

If we manually override the transformation function to be `"none"`, this results in a very different model and seasonal adjustment. Not only are the model specification and the coefficients very different, the resulting series has a much higher volatility in later years.

```{r}
m_none <- seas(AirPassengers, x11 = "", transform.function = "none")
summary(m_none)
plot(m_none)
```
Why is the tranformation function so important?
In fact, applying a logaritimc transformation is equivalent of estimating a multiplicative seasonal adjusment model. This is one of the most fundamental decisions when doing seasonal adjustment.


## Additive and multiplicative adjustment {#sec-additive-and-multiplicative-adjustment}


As you remember from @sec-introduction, Seasonal adjustment decomposes a time series into a **trend**, a **seasonal**, and an **irregular** component.
Algebraically, the fundamental identity of seasonal adjustment looks like this:

$$Y_t = T_t + S_t + I_t.$$ {#eq-additive}

We seek the decompose our observed series $Y_t$ into a trend $T_t$, a seasonal $S_t$, and an irregular $I_t$ component.
The formulation above is *additive*, i.e., the trend, the seasonal, and the irregular component sum up to the observed series.
The goal of seasonal adjustment is to subtract the seasonal component:

$$A_t = Y_t - S_t.$$

For example, an observed value of 100 with a seasonal factor of 3.2 would result in a seasonally adjusted value of 100 - 3.2 = 96.8.

Alternatively, the decomposition can be *multiplicative*:

$$Y_t = T_t \cdot S_t \cdot I_t$$ {#eq-multiplicative}

I.e., the observed series is the product of the trend and the seasonal and irregular components.
Since these are factors, the goal of seasonal adjustment is to remove seasonality by dividing by the seasonal factor.

$$A_t = \frac{Y_t}{S_t}.$$

For example, an observed value of 100 with a seasonal factor of 1.08 would result in a seasonally adjusted value of 100 / 1.08 = 92.6.
Hence for multiplicative models, values of $S_t > 1$ decrease the observed value, and $S_t < 1$ increase it.
Keep this in mind when viewing seasonal factors such as in the function `monthplot(m)`.

For a multiplicative adjustment, it is sufficient to take logarithms of the initial series and re-transform the results after the decomposition.
The `transform` spec takes care of this.

## Automated transformation choice {#sec-auto-transform}

X-13 has a built-in statistical test to decide between log and no transformation.
The choice is made by comparing the AICc[^22-transform-1] value of an ARIMA (0 1 1)(0 1 1) model fit, or a user-specified ARIMA model, to the log-transformed series and the original series.

[^22-transform-1]: With small sample sizes, a standard AIC test may select models with too many parameters.
    AICc tackles this problem by correcting for sample size.

For most practical purposes, this is an effective choice and can be left to the program to decide.
If your series has negative values, it can not be log-transformed, and automatic selection is performed.
Other restrictions on the allowed transformations exist, but these situations are rare.
We can look at the results of the transformation tests by looking at specific statistics.
The `udg()` function provides access to a large number of diagnostical statistics.The `qs()` function and the `AIC()`, `BIC()` and `logLik()` methods are wrappers that use `udg()` to access some specific diagnostical statistics.

```{r}
m <- seas(AirPassengers)
udg(m, c("aictest.trans.aicc.nolog", "aictest.trans.aicc.log"))
```

We see the AICc for log transformation is lower and hence selected.
We saw this in @sec-getting-started, were the summary of the seasonal object, `summary(m)`, has told us that `Transform: log`.
The same infor transformation can also be found in many other places such as the HTML output with `out(m)` or the udg with argument name `aictrans` such as `udg(m, "aictrans")`.

::: callout-tip
## X-13 HTML Output

X-13ARIMA-SEATAS has a built-in HTML output that offers an extensive summary of a seasonal adjustment process.
In R, this can be accessed using the `out()` function.
E.g.,

```{r, eval = FALSE}
out(m)
```
:::

The choice between `log` and `none` changes the type of seasonal decomposition that will occur and, hence, your interpretation of the seasonal factors.
With no transformation, X-13 will perform an additive seasonal adjustment specified in @eq-additive.
If log transformation is selected, X-13 will perform a multiplicative adjustment as specified in @eq-multiplicative.



## Prior modifications

Prior modifications describe a second, less commonly used transformation in X-13.
A prior modification scales each observation for known fixed effects.
These effects can be well-known and established, such as the length of a period or leap-year effects, or they can be more subjective such as a modification for a workers' strike.
We will see how this comes into the regARIMA model in @sec-regarima.
We can think of prior-modification factors as events or corrections made to your data that are fixed throughout the adjustment process.
These prior modification factors can also be permanent (default) or temporary.
Permanent modifications are excluded from the final seasonal adjustment.
Temporary modifications are removed while calculating seasonal factors but added back to the seasonally adjusted series.


## Transform options

The `transform` spec controls these options.
Some primary options within this spec are

| Spec option          | Use                                            | Example values        | default |
|-----------------|-----------------|---------------------|-----------------|
| `transform.function` | Transform function                             | `none`, `log`, `auto` | `none`  |
| `transform.aicdiff`  | adjust tolerance of AIC test for log transform | `0.0`, `3.0`, `-4.5`  | `-2.0`  |
| `xtrans`             | Prior adjustment factor                        | `seas(m, xtrans = y)` | `NULL`  |

## Case Study: `AirPassengers`

An increasing variance, also known as *heteroskadasticity* is one sign of requiring a logarithmic transform.
We have already seen that this is present in `AirPassengers`.
Let's verify that the automatic transformation identifies this.

```{r}
transformfunction(m)
```

This is also a good place to get our first look at the seasonal factors.
The `monthplot()` method offers a convenient way to look at these:

```{r}
monthplot(m)
```

Like the R base `monthplot()` function that can be applied on any time series (also on quarterly time series!), this groups time series data by months.
If you look at the January (`J`), entry, the blue bars show the evolution of the detrended data from 1949 to 1960.
The red bar shows the average seasonal factor over these years.
The smooth red lines show the seasonal factors as estimated by the model.

As you can see from the plot, there are more passengers during the summer months and fewer in the winter.
The seasonal factors change over time.
The summer peak becomes more pronounced in later years, while the local peak in February and March disappears over time.

If you want to extract the seasonal factor directly into R, you can use the `series()` function:

``` r
series(m, "seats.seasonal")
```

## Case Study: A more difficult decision

Consider the situation where you are trying to decide on transform choices for monthly retail grocery store data.
The series `grocery` is part of the *seasonalbook* package.

```{r}
library(seasonalbook)
plot(grocery)
```

Visual inspection of the series shows no immediate reason to think we need to perform a logarithmic transform.
There is possible seasonal heteroskadasity which could be mitigated by taking logs.
Perform an X-11 adjustment with all the defaults of *seasonal*

```{r}
m <- seas(grocery, x11 = "")
udg(m, c("aictest.trans.aicc.nolog", "aictest.trans.aicc.log"))
```

This is interesting since the AICc for no transformation is lower than the AICc for log transform.

```{r}
transformfunction(m)
```

The default value for transform.aicdiff is -2, meaning the program slightly prefers log transform, and the difference between the AICc values must exceed 2.
In this situation, the difference between the AICc values is -1.917597.
Suppose you were to change this option to `transform.aicdiff = 0`, then the program selects no transform.

```{r}
m2 <- seas(grocery, x11 = "", transform.aicdiff = 2)
transformfunction(m2)
```

## Exercises

1. Use *seasonal* to perform an automated seasonal adjustment of `mdeaths`.

2. Compute `"aictest.trans.aicc.nolog"` and `"aictest.trans.aicc.log"` and compare these values.

