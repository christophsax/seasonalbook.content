# X-11 {#sec-x11}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("polishing", "2023-01-21", section = "X11")  # drafting, polishing, complete
library(seasonal)
library(tsbox)
```

```{=html}
<!--
-   How to use the X11 spec

-   Case Study: Changing the length of trend and/or seasonal filter

 -->
```

The fundamental task of seasonal adjustment is to decompose a series into its constituent components: a trend, a seasonal component, and a irregular component. X-13 offers two main techniques for this task: the X-11 method and SEATS.
Ultimately, both X-11 and SEATS estimate the components by passing moving average filters over the series.
In this chapter, we will discuss X-11, one of the two main methods available.
X-11 is a nonparametric procedure that works by passing predefined moving-average filters over the data. SEATS, on the other hand, derives the moving-average filters from the underlying ARIMA model and will be discussed in in @sec-seats.


## Basics

As you remember from @sec-additive-and-multiplicative-adjustment, seasonal adjustment decomposes a time series into a trend, a seasonal, and an irregular component.
Both X-11 and SEATS achieve the decomposition by applying moving average filters over the series. In the following, we describe the basic idea behind the seasonal decomposition in X-11. If you want to perform a seasonal adjustment in R, run the following:

```{r}
m <- seas(AirPassengers, x11 = "")
summary(m)
```

#### Estimating the trend component {.unnumbered}

X-11 starts by estimating the trend component.
The trend component is estimated by applying a symmetric moving average over the series. Each point in time is averaged using a set number of observations to the left and right of the series.
Because the window is symmetric, we need the series to be extended by forecasts and backcasts.

Once the trend component is computed, we can subtract it from the original series to compute a *detrended series*.


#### Estimating the seasonal component {.unnumbered}

To estimate the seasonal component, a *seasonal filter* is applied to the detrended series. A seasonal filter is a symmetric moving average that is calculated by taking the mean of the same period across several years.
For instance, the average for January would be computed using all the January values from the time series data, February would use all February values, and so on.



<!--
    FIXME

    More formally, the seasonal filter can be expressed as follows:

 -->



#### Avoid biases {.unnumbered}

To ensure unbiased results at the series' margins, forecasts from the regARIMA model (@sec-regarima) are used to extend the series. The regARIMA model model also serves as the foundation of the initial steps in the X-11 algorithm to remove outliers and other regression effects before application of moving-averages.


#### Extreme Values {.unnumbered}

Additionally, X-11 has a built in extreme value procedure included.
This procedure identifies extreme values and replaces them.
This results in a robust procedure that can automatically choose filters and identify extreme values without much user intervention.



::: callout-note
## Outliers and Extreme values

We will discuss extreme values and outliers in more detail in @sec-outliers.

The terms outlier and extreme value seem interchangeable.
In X-13, these refer to very different types of effects.
An outlier is identified by the regARIMA model in Part A (see below) of the X-11 method.
An extreme value is a value that is large enough to effect the results of a moving-average filter but is not identified by the regARIMA automatic modeling identification.
Outliers are prior-adjusted out of the series while extreme values are replaced within the X-11 procedure.

Both types end up in the seasonally adjusted series.
Extreme values are assigned to the irregular component and are hence included in the seasonally adjusted series.
Outliers get included in Part D (see below) when X-11 calculates the final seasonal factors using the original series including outlier effects.
:::


#### Go in circles {.unnumbered}

X-11 iteratively refines this process. Each iteration enhances the estimated components by selecting more appropriate filters and managing outliers and regression effects.

In the default adjustment from above, a decomposition is run 3 times along with a pre-processing step to fit the regARIMA model.
This procedure can be seen in great detail in @ladiray12.
The overview of each step:

Part A

:   Prior adjustments including regARIMA modeling of outliers, trading day and moving holiday effects.

Part B

:   First application of seasonal decomposition.
    Calculate initial extreme value weights.

Part C

:   Second estimation of seasonal and trend.
    Final estimation of extreme value weights.

Part D

:   Final estimation of seasonally adjusted series, seasonal factors, trend, irregular.
    Combined factors incorporate the trading day and moving holiday regression effects estimated in Part A


## R-Fundamentals: A Simple Decomposition {#sec-simple-decomposition}

In order to deepen our understanding of the X-11 method, we start with a "by-hand" approach R.
As a basic trend filter, we trend filter—a 2x12 moving average. The weights for this filter are distributed as 1/24, followed by 1/12 for the next 11 points, and then 1/24 again. We apply these weights to estimate the trend of the `AirPassengers` series:

```{r x11-trend}
observed <- AirPassengers
filter_trend = c(1/24, rep(1/12, 11), 1/24)
trend = stats::filter(observed, filter = filter_trend, sides = 2)
tsbox::ts_plot(observed, trend)
```

After obtaining the trend, we estimate the seasonal component of the detrended series using a 3x3 seasonal filter with weights (1,2,3,2,1)/9, applied consistently across the same season:

```{r x11-seasonal-component}
detrended <- observed - trend
filter_seas = c(1, rep(0, 11), 2, rep(0, 11), 3, rep(0, 11), 2, rep(0, 11), 1) / 9
seasonal = stats::filter(detrended, filter = filter_seas, sides = 2)
tsbox::ts_plot(detrended, seasonal)
```

Subtracting this seasonal estimate provides us with a rudimentary seasonal adjustment:


```{r x11-seasonal-adj}
adjusted = observed - seasonal
tsbox::ts_plot(observed, adjusted)
```

While this basic adjustment is insightful, it also reveals limitations, particularly at the series ends, underscoring the necessity for regARIMA modeling to extend forecasts. Another challenge is the interplay between trend and seasonality estimation—accurately estimating one in the presence of the other is complex.

These observations pave the way for the X-11 method, which iteratively refines this process. Each iteration enhances the estimated components by selecting more appropriate filters and managing outliers and regression effects.


<!--
During these steps the trend filter is automatically chosen based the noise-to-signal ratios, labeled I/C in the output file.
The seasonal moving average is determined by the Global Moving Seasonality Ratio (GMSR).
Being able to understand the

When using the x11 spec you can change the length of the filter used for the trend and seasonal components with the `trendma` and `seasonalma` arguments respectively.
Additionally, `sigmalim` will control the amount of extreme value adjustment that is done during the seasonal adjustment.
 -->
## Frequency Domain (optional)

We present the following as optional reading material.
For those interesting in simply performing seasonal adjustment, an understanding of the frequency domain of a time series, is not mandatory.
However, the spectral domain representation will help the interested reader further understand the impact a linear filter has on a time series.
Since both X-11 and SEATS use linear filters this will deepen the users understanding of whichever seasonal adjustment procedure is chosen.

Seasonal adjustment is highly motivated by the study, estimation, and ultimately removal of regular fluctuations in a time series.
The words *regular fluctuations* immediately leads us to trigonometric functions sine and cosine.
It turns out, there exist two equivalent representations of a time series.
The first, and usually easier for beginners to understand, is the time domain representation.
This is expressing how $X_t$ evolves as time $t$ evolves.
For example, an MA(1) time domain representation:

$$X_t = w_t + \theta w_{t-1}$$

The second, is a frequency domain representation of a series.
Here, $X_t$ is represented as the sum of trigonometric functions.
More specifically, the spectral density of $X_t$ is the fourier transform of the acf of the series.
$$f_X(\nu) = \sum_{h = - \infty}^{\infty} \gamma(h) e^{-2\pi i \nu h}$$ For example, the spectral density of an MA(1) is: $$f_X(\nu) = \sigma^2 \left( 1 + \theta^2 + 2\theta\cos(2\pi\nu) \right)$$

The important concept here is to understand that these representations are equivalent; meaning they contain the same information about a time series, such as encoding the acf function.

::: callout-tip
## Where does the term "White Noise" come from?

The spectral density of an uncorrelated sequence with variance $\sigma^2$ is simply $f(\nu) = \sigma^2$.
Notice this is not a function of any frequencies but just a constant for any $\nu$.
Hence, it is a stochastic process that equally weight all frequencies in the spectrum.
This is precisely where the names white noise comes from as white light has the same property of reflecting all color bands equally, combining to produce white light.
:::

Now that we know we can express a time series either in the time domain or as a sum of sin and cosine curves, we get to the important part for seasonal adjustment - how does a linear filter effect the input series?
Assume we want to pass a moving-average linear filter over our data $X_t$ with weights $\ldots, w_{-2}, w_{-1}, w_{0}, w_{1}, w_{2}, \ldots$.
Assume the output of the linear filter will be $Y_t$ such that $$Y_t = \sum_{j = -\infty}^{\infty} w_j X_{t+j} = 
\ldots + w_{-2}X_{t-2} + w_{-1}X_{t-1} +  w_{0}X_{t} + w_{1}X_{t+1} + w_{2}X_{t+2} + \ldots$$ This type of linear filter can be expressed as a linear operator in terms of the backshift operator $B$ , where $BX_t = X_{t-1}$ and $B^{-1}X_t = X_{t+1}$.
$$W(B) = \ldots + w_{-2}B^2 + w_{-1}B +  w_{0} + w_{1}B^{-1} + w_{2}B^{-2} + \ldots$$ and hence $Y_t = W(B)X_t$.
We can now express the spectral density of $Y_t$ in terms of the input spectral density $X_t$.
$$f_Y(\nu) = \underbrace{\lvert W(e^{2\pi i \nu}) \rvert^2}_{\text{Square Gain Function}} f_X(\nu)$$

There is some mathematical machinery needed when understanding exactly what the square-gain function, $\lvert W(e^{2\pi i \nu}) \rvert^2$, is.
However, for the sake of this text we just know that it tells us exactly the frequencies of $X_t$ that amplified in the output $Y_t$ as well as the frequencies of $X_t$ that will be annihilated (when the square-gain function equals 0).

Let's look at an example spectrum for the airline model.
Instead of deriving the result, the following code simulates observations from an airline model with $\theta = .5$ and $\Theta = .9$.
The spectrum is then estimated using a parametric estimator using the `spec.ar` function.
Details of this estimation can be found in (Brockwell and Davis).

```{r}
library(forecast)
set.seed(123)
model <- Arima(y = ts(rnorm(1000),freq=12), 
               order=c(0,1,1), 
               seasonal=c(0,1,1),
               fixed=c(theta=-0.5, Theta=-0.9))
x <- simulate(model, nsim=10000)
fx = spec.ar(x, order = 36, plot = TRUE)

# Pass a trend filter over data
x_trend = stats::filter(x, filter = filter_trend, sides = 2)
fx_trend = spec.ar(x_trend, na.action = na.pass)

# Remove trend to leave seasonal + irregular
x_seasonal = x - x_trend
fx_seasonal = spec.ar(x_seasonal, na.action = na.pass)
```

## X-11 Filters

In the X-11 method, the choice of moving average filters plays a crucial role in seasonal adjustment. Users have the flexibility to select the length of both the trend and seasonal moving average filters, impacting the stability and responsiveness of the seasonal component. For example, the following model uses a short `3x1` filter to identify the seasonal component:

```{r}
m_short <- seas(AirPassengers, x11.seasonalma = "s3x1")
plot(m_short)
```

On the other hand, the following uses a long `3x9` filter:


```{r}
m_long <- seas(AirPassengers, x11.seasonalma = "s3x9")
plot(m_long)
```

Generally speaking, longer filters imply a more stable seasonal component and shorter filters a more changing seasonal pattern. We can see this by comparing the `monthplot()` outputs of the estimations.

```{r}
monthplot(m_short)
```

As you can see, the seasonal component is smoother with the longer filter:

```{r}
monthplot(m_long)
```

Longer filters involve more data points in the calculation of the seasonal component at each time point. Therefore, they typically result in smaller revisions when new data is added to the series. However, these revisions can impact historical data values further back in the time series.

In contrast, shorter filters, which use fewer data points, are more likely to produce larger revisions with each new data addition. These revisions, while more significant, extend less far back into the historical data.

If a user does not select a filter, the X-11 method defaults to automatic filter selection. To understand the implications of filter length, consider the finite set of options available during an X-11 adjustment. @tbl-x11-filters details the different filters that can be applied to both the seasonal and trend components of the series.

| Value        | Description                                                                                                                                                                                                                     |
|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `s3x1`       | 3×1 moving average                                                                                                                                                                                                              |
| `s3x3`       | 3×3 moving average                                                                                                                                                                                                              |
| `s3x5`       | 3×5 moving average                                                                                                                                                                                                              |
| `s3x9`       | 3×9 moving average                                                                                                                                                                                                              |
| `s3x15`      | 3×15 moving average                                                                                                                                                                                                             |
| `stable`     | Stable seasonal filter. A single seasonal factor for each calendar month or quarter is generated by calculating the simple average of all the values for each month or quarter (taken after detrending and outlier adjustment). |
| `x11default` | A 3×3 moving average is used to calculate the initial seasonal factors in each iteration, and a 3×5 moving average to calculate the final seasonal factors.                                                                     |

: Filters available in X11 {#tbl-x11-filters tbl-colwidths="\[30,70\]"}


```{r, echo=FALSE}
# Function to find seasonal filter weight by passing impuse through
find_seasonal_PxQ_filter_wts = function(P, Q) {
  v = rep(0, 100)
  v[50] = 1
  v2 = stats::filter(v, rep(1 / Q, Q), sides = 2)
  v3 = stats::filter(v2, rep(1 / P, P), sides = 2)
  wts = v3[v3 > 0 & !is.na(v3)]
  wts
}
```

```{r, echo=FALSE}
# 3 x 3 seasonal filter wts 
w = find_seasonal_PxQ_filter_wts(3, 3)
w_len = (length(w) - 1) / 2
plot((-w_len):(w_len), w, type = "b", ylim = c(0, max(w)), xlab = "time lag", ylab = "filter weight", main = "3x3 Seasonal Filter wts")
abline(h = 0, lty = 'dotted')
```

```{r, echo=FALSE}
# 3 x 5 seasonal filter wts 
w = find_seasonal_PxQ_filter_wts(3, 5)
w_len = (length(w) - 1) / 2
plot((-w_len):(w_len), w, type = "b", ylim = c(0, max(w)), xlab = "time lag", ylab = "filter weight", main = "3x5 Seasonal Filter wts")
abline(h = 0, lty = 'dotted')
```

```{r, echo=FALSE}
# 3 x 9 seasonal filter wts 
w = find_seasonal_PxQ_filter_wts(3, 9)
w_len = (length(w) - 1) / 2
plot((-w_len):(w_len), w, type = "b", ylim = c(0, max(w)), xlab = "time lag", ylab = "filter weight", main = "3x9 Seasonal Filter wts")
abline(h = 0, lty = 'dotted')
```

```{r, echo=FALSE}
# 3 x 15 seasonal filter wts 
w = find_seasonal_PxQ_filter_wts(3, 15)
w_len = (length(w) - 1) / 2
plot((-w_len):(w_len), w, type = "b", ylim = c(0, max(w)), xlab = "time lag", ylab = "filter weight", main = "3x15 Seasonal Filter wts")
abline(h = 0, lty = 'dotted')
```

## Extreme value

The X11 method is sensitive to outliers.
Beyond the specified regressors (AOs, level shifts, temporary changes, etc), an X11 adjustment will replace extreme values after the initial crude trend estimation occurs in the first iteration of the X11 method.
The replacement procedure looks as follows:

```{mermaid}
%%| label: fig-spec-interaction
%%| fig-width: 9
%%| fig-cap: |
%%|   Default behavior of Extreme value replacement procedure. 
flowchart LR
    A(  Estimate standard deviation <br> of irregular, s  )-->B(Compare SI-ration to <br> multiples of s)
    B-->C(SI < 1.5 * s)
    B-->D(1.5 * s < SI < 2.5 * s)
    B-->E(SI > 2.5 * s)
    C --> F(SI unchanged)
    D --> G(SI linearly weighted)
    E --> H(SI fully weighted)
```

Users can change the multiples of $\sigma$ that are converted to extreme values.
This is done with the `sigmalim` option within the `x11` spec.
This option should be a vector of length 2 that specifies when weighting should begin and when full weight of zero should be applied.
Between the endpoints of the specified vector a linear weight will be applied.
SI ratios are replaced with an average of the two nearest SI ratios from the same month/quarter.
One caveat being that only fully weighted SI ratios are used for SI ratio replacement.
Hence, if too small of a $\sigma$ limit is used the SI ratios used to replace an extreme value should be many years away.

```{r}
m = seas(AirPassengers, x11 = "")
unmodified_SIratio <- series(m, "d8")
modified_SIratio   <- series(m, "d9")
seasonal_factors <- series(m, "d10")
tsbox::ts_dygraphs(cbind(unmodified_SIratio, modified_SIratio, seasonal_factors))
```

```{r}
m = seas(AirPassengers, x11 = "", x11.sigmalim = c(1, 2))
unmodified_SIratio <- series(m, "d8")
modified_SIratio   <- series(m, "d9")
seasonal_factors <- series(m, "d10")
tsbox::ts_dygraphs(cbind(unmodified_SIratio, modified_SIratio, seasonal_factors))
```

It should be noted that extreme value choices can greatly affect the seasonal adjustment.

::: callout-warning
### SI ratio / SI difference

In a multiplicative adjustment, the detrended series is called the SI ratio.
It is an estimate of the seasonal component.
The SI ratio is used to identify extreme values during the initial and intermediate steps of the X-11 method.
:::

## Additive and multiplicative (again)

The X-13ARIMA-SEATS development was highly motivated to study economic time series.
As such, the default seasonal adjustment mode is multiplicative due to most seasonal economic time series displaying seasonal fluctuations that increase and decrease along with the level of the time series.

If your series does not have this feature then additive adjustment might be more appropriate.
This can be changed in the `mode` argument of the x11 spec.
For example, `seas(x, x11.mode = 'add')` will perform an additive x11 run.
There exist two other models for decomposition, pseudo-additive and log additive.
These are less common than additive and multiplicative models and are not the focus of this text.
If your series has some extremely small values in certain months (quarters) then pseudo-additive models could be worth further investigation.
It has been observed that when multiplicative seasonal adjustment produces more extreme values in conjunction with small seasonal factors then pseudo-additive adjustment should be explored.

<!-- NEED TO SHOW USERS HOW TO VIEW THEIR EXTREME VALUES - D8.B TABLE DESIGNATIONS NEXT TO OBSERVATIONS. A good reference on the subject is Baxter (1994). -->

## Case study

```{r x11-case-study}

tsbox::ts_plot(
  s3x1 = predict(seas(AirPassengers, x11.seasonalma = "s3x1")),
  s3x15 = predict(seas(AirPassengers, x11.seasonalma = "s3x15"))
)

```
<!--

## Points to include in Chapter

-   Level shifts are included with the trend component while AOs and extreme values are included in the irregular.
-   Changing filters can affect which values are extreme
-   Changing sigma limits changes the extreme values and can affect what filter seems most appropriate
    -   Experiment with changing filters and sigma limits for your series to see the results
 -->
